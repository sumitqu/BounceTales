<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bounce Tales — Full Style (100 Levels)</title>
  <style>
    :root{--bg:#071423;--panel:#0f1724;--accent:#ff5c5c;--muted:#9aa6b2}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
    body{background:linear-gradient(180deg,#071027 0%, #061423 60%);display:flex;align-items:center;justify-content:center;color:#e6eef6}
    .wrap{width:980px;max-width:98vw;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));box-shadow:0 10px 30px rgba(2,6,23,.6);border-radius:12px;padding:18px;display:grid;grid-template-columns:1fr 320px;gap:12px}
    canvas{background:linear-gradient(180deg,#071a2b 0%, #061423 100%);border-radius:8px;width:100%;height:640px;display:block}
    .sidebar{padding:12px;background:rgba(255,255,255,0.02);border-radius:8px}
    h1{margin:0 0 8px 0;font-size:16px}
    p{margin:6px 0;color:var(--muted);font-size:13px}
    .controls{display:grid;gap:6px;margin-top:8px}
    .kbd{background:#081223;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;font-size:13px}
    .btn{display:inline-block;padding:8px 10px;border-radius:6px;background:#0b1a2b;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
    .footer{margin-top:14px;color:var(--muted);font-size:12px}
    .hud{position:absolute;left:22px;top:14px;color:#fff;font-weight:700;text-shadow:0 1px 0 rgba(0,0,0,.6)}
    .touch-row{display:flex;gap:12px;margin-top:10px}
    .touch-btn{flex:1;padding:16px 10px;border-radius:8px;background:rgba(255,255,255,0.02);text-align:center;user-select:none; font-size: 16px; font-weight: 700;}
    .muted{color:var(--muted);font-size:13px}
    .level-preview{height:240px;background:linear-gradient(180deg,#071227 0%, #081520 100%);border-radius:6px;padding:8px;overflow:auto;font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <div style="position:relative;">
      <div class="hud" id="hud">Level 1 &nbsp; &nbsp; Lives: 5 &nbsp; &nbsp; Mode: Classic</div>
      <canvas id="game" width="640" height="640"></canvas>
    </div>

    <div class="sidebar">
      <h1>Bounce Tales — Full Bounce Style</h1>
      <p class="muted">Controls: **Arrows** to move/jump. **Z/X** to change size. **R** to restart.</p>

      <div class="controls">
        <div class="kbd">Tip: **Shrink** to fit tunnels, **Expand** to hit switches.</div>

        <div style="display:flex;gap:8px;margin-top:8px">
          <div class="btn" id="prev">Prev Level</div>
          <div class="btn" id="next">Next Level</div>
          <div class="btn" id="restart">Restart</div>
        </div>

        <div class="level-preview" id="levelPreview"></div>

        <div class="footer">100 levels with platforms, spikes, tunnels, and puzzles.</div>

        <div style="margin-top:12px">
          <div class="muted">Touch Controls</div>
          <div class="touch-row">
            <div class="touch-btn" id="touch-left">LEFT</div>
            <div class="touch-btn" id="touch-jump">JUMP</div>
            <div class="touch-btn" id="touch-right">RIGHT</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ------------------- Engine (improved) -------------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const levelPreview = document.getElementById('levelPreview');
  const W = canvas.width, H = canvas.height;

  // Player
  const player = {
    x:60, y:520, r:18, baseR:18,
    vx:0, vy:0, onGround:false,
    shrunk:false, shrinkFactor:0.55,
    color:'#ff5c5c',
    // Track the platform the player is standing on for moving platform logic
    standingOn: null,
  };

  // physics params
  let gravity = 0.9;
  let friction = 0.75;
  let airDrag = 0.87;
  let keys = {};
  let currentLevel = 0;
  let lives = 5; 
  
  let gameState = 'playing'; // 'playing', 'replaying', 'paused'
  let playerHistory = []; // REPLAY SYSTEM: Stores player position/radius for replay
  let replayTimer = 0;
  // **FIXED CONSTANTS**
  const replayLengthMs = 3000; // Duration of player movement to show
  const replayDurationFactor = 2; // 0.5x speed means 2x playback time (3000ms * 2 = 6000ms playback)
  const historySampleRate = 16; // Sample every 16ms (approx 60 FPS)
  let timeSinceLastSample = 0;

  // World objects types: solid, spike, goal, moving (solid with vx/vy), switch, door

  // --- Level Generator: handcraft templates and then vary to produce 100 levels ---
  const templates = [];

  // Helper to push base ground
  function baseGround(items){ items.push({x:0,y:600,w:640,h:40,type:'solid'}); }

  // EASY: tutorial, gentle gaps
  templates.push(function(){ let items=[]; baseGround(items); items.push({x:150,y:520,w:120,h:16,type:'solid'}); items.push({x:340,y:480,w:120,h:16,type:'solid'}); items.push({x:540,y:420,w:80,h:16,type:'solid'}); items.push({x:600,y:380,w:40,h:40,type:'goal'}); return {name:'Tutorial — Basics', start:{x:60,y:520}, items}; });

  templates.push(function(){ let items=[]; baseGround(items); items.push({x:100,y:520,w:60,h:120,type:'solid'}); items.push({x:260,y:520,w:60,h:120,type:'solid'}); items.push({x:200,y:420,w:84,h:16,type:'solid'}); items.push({x:360,y:480,w:120,h:16,type:'solid'}); items.push({x:580,y:380,w:40,h:40,type:'goal'}); return {name:'Tight Tunnel', start:{x:40,y:540}, items}; });

  templates.push(function(){ let items=[]; baseGround(items); items.push({x:180,y:560,w:120,h:16,type:'solid'}); items.push({x:320,y:560,w:120,h:16,type:'solid'}); items.push({x:260,y:600,w:20,h:40,type:'spike'}); items.push({x:420,y:600,w:20,h:40,type:'spike'}); items.push({x:580,y:520,w:40,h:40,type:'goal'}); return {name:'Spikes & Jump', start:{x:40,y:540}, items}; });

  // MIDDLE: moving platforms, shrink-to-pass tunnels
  templates.push(function(){ let items=[]; baseGround(items); items.push({x:140,y:520,w:100,h:16,type:'solid'}); 
    // VERTICAL: REDUCED: 0.6 -> 0.3 (50% reduction)
    items.push({x:300,y:480,w:120,h:16,type:'moving',vx:0,vy:0.3,range:60}); 
    items.push({x:480,y:420,w:140,h:16,type:'solid'}); items.push({x:300,y:360,w:80,h:16,type:'solid'}); items.push({x:600,y:320,w:40,h:40,type:'goal'}); return {name:'Rising Platform', start:{x:60,y:520}, items}; });

  templates.push(function(){ let items=[]; baseGround(items); // shrink puzzle
    items.push({x:120,y:540,w:60,h:100,type:'solid'});
    items.push({x:220,y:520,w:40,h:16,type:'solid'});
    // narrow tunnel
    items.push({x:300,y:520,w:16,h:140,type:'solid'});
    items.push({x:340,y:540,w:120,h:16,type:'solid'});
    items.push({x:580,y:480,w:40,h:40,type:'goal'});
    return {name:'Shrink & Slip', start:{x:40,y:520}, items}; });

  templates.push(function(){ let items=[]; baseGround(items); items.push({x:120,y:540,w:120,h:16,type:'solid'}); items.push({x:260,y:520,w:60,h:16,type:'spike'}); items.push({x:340,y:500,w:60,h:16,type:'solid'}); 
    // HORIZONTAL: REDUCED: 1 -> 0.3 (70% reduction)
    items.push({x:440,y:460,w:60,h:16,type:'moving',vx:0.3,vy:0,range:120}); 
    items.push({x:600,y:420,w:40,h:40,type:'goal'}); return {name:'Moving Danger', start:{x:40,y:520}, items}; });

  // HARDER: switch-doors, precision tunnels
  templates.push(function(){ let items=[]; baseGround(items); items.push({x:160,y:540,w:80,h:16,type:'solid'}); items.push({x:300,y:520,w:60,h:16,type:'solid'}); items.push({x:420,y:480,w:16,h:120,type:'solid'}); // vertical bar forming narrow corridor
    items.push({x:500,y:520,w:40,h:16,type:'solid'}); items.push({x:600,y:420,w:40,h:40,type:'goal'}); return {name:'Precision Corridor', start:{x:60,y:520}, items}; });

  templates.push(function(){ let items=[]; baseGround(items); // alternating spikes
    for(let i=1;i<6;i++) items.push({x:80*i,y:600,w:20,h:40,type:'spike'});
    items.push({x:520,y:520,w:120,h:16,type:'solid'}); items.push({x:600,y:480,w:40,h:40,type:'goal'}); return {name:'Spike Gauntlet', start:{x:40,y:520}, items}; });

  // create 100 levels by cycling/transforming templates with increasing difficulty
  const levels = [];
  let levelCount = 100; // Increased level count!
  for(let i=0;i<levelCount;i++){
    // pick one template and mutate it
    const tpl = templates[i % templates.length]();
    let copy = JSON.parse(JSON.stringify(tpl));

    // Apply transformations to prevent repetition and increase difficulty later
    if (i % templates.length === 0 && i > 0) { // Mirror/transform on the start of a cycle
      // Mirror the X axis of objects (Roughly center at 320)
      copy.items.forEach(item => {
        item.x = W - item.x - item.w;
        // Mirror horizontal velocity
        if (item.vx) item.vx *= -1;
      });
      copy.start.x = W - copy.start.x;
      copy.name = `MIRRORED ${copy.name}`;
    }

    copy.name = `${i+1}. ${copy.name}`;

    // increase challenge: add spikes and moving platforms as level number grows
    if(i>10) copy.name += ' ★';
    if(i>30){ // add more spikes
      copy.items.push({x: 100 + (i*9)%400, y:600, w:20, h:40, type:'spike'});
    }
    if(i>50){ // add moving platforms (REDUCED SPEED)
      // HORIZONTAL: REDUCED: 0.8/-0.8 -> 0.24/-0.24 (70% reduction)
      const vx_base = (i%2?0.24:-0.24); 
      // VERTICAL: REDUCED: 0.6/-0.6 -> 0.3/-0.3 (50% reduction)
      const vy_base = (i%3===0 ? (i%2?0.3:-0.3) : 0); 
      copy.items.push({x: 200 + (i*11)%300, y:480 - (i%3)*30, w:80, h:16, type:'moving', vx: vx_base, vy: vy_base, range:100 + (i%4)*30});
    }
    if(i>70){ // narrow tunnels requiring shrink
      copy.items.push({x: 300 + (i*5)%220, y:420, w:16, h:120, type:'solid'});
    }
    // set reasonable start point if missing
    if(!copy.start) copy.start = {x:60,y:520};
    // final level endings
    if(Math.random() > 0.85){ copy.items.push({x:600,y:320,w:40,h:40,type:'goal'}); }
    // ensure at least one goal exists
    if(!copy.items.some(it=>it.type==='goal')) copy.items.push({x:600,y:320,w:40,h:40,type:'goal'});
    levels.push(copy);
  }

  // add some handcrafted boss/puzzle near the end
  // Levels 98, 99, 100 (array indices 97, 98, 99) are manually defined or modified here

  // Level 98 (index 97) - Based on Elevator Puzzle
  levels[97] = {
    name: '98. The Grand Elevator (Slow)', start:{x:60,y:520}, items:[{x:0,y:600,w:640,h:40,type:'solid'},{x:160,y:520,w:80,h:16,type:'solid'},
    // ELEVATOR: REDUCED: -0.7 -> -0.35 (50% reduction)
    {x:280,y:520,w:80,h:16,type:'moving',vx:0,vy:-0.35,range:160},{x:420,y:420,w:80,h:16,type:'solid'},{x:540,y:360,w:40,h:16,type:'solid'},{x:600,y:320,w:40,h:40,type:'goal'}]
  };
  // Level 99 (index 98)
  levels[98] = {
    name: '99. Narrow Final Approach', start:{x:40,y:540}, items:[{x:0,y:600,w:640,h:40,type:'solid'},{x:120,y:520,w:40,h:120,type:'solid'},{x:180,y:520,w:40,h:120,type:'solid'},{x:240,y:520,w:40,h:120,type:'solid'},{x:300,y:520,w:40,h:120,type:'solid'},{x:420,y:520,w:120,h:16,type:'solid'},{x:600,y:420,w:40,h:40,type:'goal'}]
  };
  // Level 100 (index 99)
  levels[99] = {
    name: '100. FINAL TEST (Slow)', start:{x:60,y:520}, items:[{x:0,y:600,w:640,h:40,type:'solid'},{x:140,y:540,w:80,h:16,type:'solid'},{x:240,y:520,w:60,h:16,type:'spike'},
    // FINAL TEST: REDUCED: 1.2 -> 0.36 (70% reduction)
    {x:320,y:500,w:120,h:16,type:'moving',vx:0.36,vy:0,range:140},{x:480,y:460,w:16,h:120,type:'solid'},{x:600,y:420,w:40,h:40,type:'goal'}]
  };

  // collision helpers
  function collideRect(px,py,pr,rx,ry,rw,rh){
    const nx = Math.max(rx, Math.min(px, rx+rw));
    const ny = Math.max(ry, Math.min(py, ry+rh));
    const dx = px - nx; const dy = py - ny; return (dx*dx + dy*dy) <= pr*pr;
  }

  function resetLevel(){
    const lvl = levels[currentLevel];
    player.x = lvl.start.x; player.y = lvl.start.y; player.vx=0; player.vy=0; player.r=player.baseR; player.shrunk=false; lives = Math.max(0,lives); // Ensure lives don't reset to 5 if below 5
    player.standingOn = null;
    gameState = 'playing'; // Reset game state
    playerHistory = []; // Clear history for the new attempt
    // attach runtime fields for moving platforms
    for(const it of lvl.items){ 
      if(it.type==='moving'){ 
        it._origX = it.x; it._origY = it.y; it._t = 0; 
        it._prevX = it.x; it._prevY = it.y; // For tracking platform velocity
      } 
    }
    updatePreview();
  }

  function updatePreview(){
    const lvl = levels[currentLevel];
    levelPreview.innerHTML = `<strong>${lvl.name}</strong><br>Objects:<br>` + lvl.items.map(it=>`- ${it.type} @ ${it.x},${it.y} (${it.w}x${it.h})${it.type==='moving'? ' (moving)':''}`).join('<br>');
    hud.textContent = `Level ${currentLevel+1} / ${levels.length}  Lives: ${lives}`;
  }

  function dieAndRespawn(){ 
    lives -=1; 
    
    if(lives <= 0){
      // Game Over - No Replay
      currentLevel=0; 
      lives=5; 
      resetLevel();
    } else {
      // **REPLAY START: Set game state and timer**
      gameState = 'replaying';
      replayTimer = 0;
      hud.textContent = `Level ${currentLevel+1} / ${levels.length}  Lives: ${lives} - Replaying Death!`;
    }
  }
  
  function nextLevel(){ 
    currentLevel++; 
    if(currentLevel>=levels.length) currentLevel=0; 
    playerHistory = []; // Clear history on level win
    resetLevel(); 
  }

  // Input
  window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.key.toLowerCase()==='r') resetLevel(); });
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });
  // touch
  document.getElementById('touch-left').addEventListener('touchstart', e=>{ keys['arrowleft']=true; e.preventDefault();});
  document.getElementById('touch-left').addEventListener('touchend', e=>{ keys['arrowleft']=false; e.preventDefault();});
  document.getElementById('touch-right').addEventListener('touchstart', e=>{ keys['arrowright']=true; e.preventDefault();});
  document.getElementById('touch-right').addEventListener('touchend', e=>{ keys['arrowright']=false; e.preventDefault();});
  document.getElementById('touch-jump').addEventListener('touchstart', e=>{ keys['arrowup']=true; setTimeout(()=>keys['arrowup']=false,150); e.preventDefault();});

  document.getElementById('prev').addEventListener('click', ()=>{ currentLevel = Math.max(0,currentLevel-1); resetLevel(); });
  document.getElementById('next').addEventListener('click', ()=>{ currentLevel = Math.min(levels.length-1,currentLevel+1); resetLevel(); });
  document.getElementById('restart').addEventListener('click', ()=>resetLevel());

  // shrink toggle
  function applyShrink(val){ if(val && !player.shrunk){ player.r = Math.max(8, player.baseR*player.shrinkFactor); player.shrunk=true; } else if(!val && player.shrunk){ player.r = player.baseR; player.shrunk=false; } }

  // update moving platforms
  function updateMovingPlatforms(lvl,dt){ 
    for(const it of lvl.items){ 
      if(it.type==='moving'){ 
        it._prevX = it.x; it._prevY = it.y; // Store previous position
        it._t += dt; 
        // simple sinusoidal movement
        it.x = it._origX + Math.sin(it._t*0.01) * (it.vx ? it.range : 0);
        it.y = it._origY + Math.sin(it._t*0.01) * (it.vy ? it.range : 0);
      } 
    } 
  }

  // resolve collisions with better separation handling
  function resolveCollisions(){ 
    player.onGround = false; 
    const lvl = levels[currentLevel];

    for(const it of lvl.items){ 
      if(it.type==='solid' || it.type==='moving' || it.type==='spike' || it.type==='goal'){
        if(collideRect(player.x, player.y, player.r, it.x, it.y, it.w, it.h)){
          
          // Trigger Death/Goal logic BEFORE pushing out
          if(it.type==='spike'){ dieAndRespawn(); return; } 
          if(it.type==='goal'){ nextLevel(); return; } 
          
          // Find nearest point for resolution
          const nx = Math.max(it.x, Math.min(player.x, it.x+it.w));
          const ny = Math.max(it.y, Math.min(player.y, it.y+it.h));
          const dx = player.x - nx; const dy = player.y - ny;
          
          const penetrationX = player.r - Math.abs(dx);
          const penetrationY = player.r - Math.abs(dy);

          if(penetrationX > 0 && penetrationY > 0) { // Overlapping
            // FIXED: Prioritize pushing out along the minimum penetration axis
            if(penetrationY < penetrationX){
              // Resolve Y collision
              if(dy > 0){ // below
                player.y = it.y
