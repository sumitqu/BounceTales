// ... (The HTML and CSS remain the same) ...

  <script>
  // ------------------- Engine (improved) -------------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const levelPreview = document.getElementById('levelPreview');
  const W = canvas.width, H = canvas.height;

  // Player
  const player = {
    x:60, y:520, r:18, baseR:18,
    vx:0, vy:0, onGround:false,
    shrunk:false, shrinkFactor:0.55,
    color:'#ff5c5c',
    // **IMPROVED**: track the platform the player is standing on
    standingOn: null,
  };

  // physics params
  let gravity = 0.9;
  // INCREASED friction as requested: stronger damping
  let friction = 0.86; // lower => more damping
  let airDrag = 0.995;
  let keys = {};
  let currentLevel = 0;
  let lives = 3;

// ... (Level templates/generation code remains the same) ...

  // collision helpers
  function collideRect(px,py,pr,rx,ry,rw,rh){
    const nx = Math.max(rx, Math.min(px, rx+rw));
    const ny = Math.max(ry, Math.min(py, ry+rh));
    const dx = px - nx; const dy = py - ny; return (dx*dx + dy*dy) <= pr*pr;
  }

  function resetLevel(){
    const lvl = levels[currentLevel];
    player.x = lvl.start.x; player.y = lvl.start.y; player.vx=0; player.vy=0; player.r=player.baseR; player.shrunk=false; lives = Math.max(1,lives);
    player.standingOn = null; // **IMPROVED**: Reset standingOn
    // attach runtime fields for moving platforms
    for(const it of lvl.items){ 
      if(it.type==='moving'){ 
        it._origX = it.x; it._origY = it.y; it._t = 0; 
        it._prevX = it.x; it._prevY = it.y; // **IMPROVED**: for tracking platform velocity
      } 
    }
    updatePreview();
  }

// ... (updatePreview, dieAndRespawn, nextLevel, Input, applyShrink remain the same) ...

  // update moving platforms
  function updateMovingPlatforms(lvl,dt){ 
    for(const it of lvl.items){ 
      if(it.type==='moving'){ 
        it._prevX = it.x; it._prevY = it.y; // **IMPROVED**: Store previous position
        it._t += dt; 
        // simple sinusoidal movement
        it.x = it._origX + Math.sin(it._t*0.01) * (it.vx ? it.range : 0);
        it.y = it._origY + Math.sin(it._t*0.01) * (it.vy ? it.range : 0);
      } 
    } 
  }

  // resolve collisions with better separation handling
  function resolveCollisions(dt){ // **FIXED**: now takes dt
    player.onGround = false; 
    let hitPlatform = false; // **FIXED**: track if player is currently hitting a solid platform
    const lvl = levels[currentLevel];

    for(const it of lvl.items){ 
      if(it.type==='solid' || it.type==='moving' || it.type==='spike' || it.type==='goal'){
        if(collideRect(player.x, player.y, player.r, it.x, it.y, it.w, it.h)){
          
          // **IMPROVED**: Check if standing on this platform
          if ((it.type === 'solid' || it.type === 'moving') && player.y < it.y + it.h && player.y > it.y - player.r) {
            hitPlatform = true;
          }

          // find nearest point
          const nx = Math.max(it.x, Math.min(player.x, it.x+it.w));
          const ny = Math.max(it.y, Math.min(player.y, it.y+it.h));
          const dx = player.x - nx; const dy = player.y - ny;
          
          const penetrationX = player.r - Math.abs(dx);
          const penetrationY = player.r - Math.abs(dy);

          if(penetrationX > 0 && penetrationY > 0) { // Overlapping
            // **FIXED**: Prioritize pushing out along the minimum penetration axis
            if(penetrationY < penetrationX){
              // Resolve Y collision
              if(dy > 0){ // below
                player.y = it.y + it.h + player.r + 0.01; player.vy = 0; 
              } else { // above (landing on)
                player.y = it.y - player.r - 0.01; player.vy = 0; player.onGround = true; 
                player.standingOn = it; // **IMPROVED**: Set standing platform
              }
            } else {
              // Resolve X collision
              if(dx > 0){ player.x = it.x + it.w + player.r + 0.01; player.vx = 0; } else { player.x = it.x - player.r - 0.01; player.vx = 0; }
            }
          }

          if(it.type==='spike'){ dieAndRespawn(); return; } // **FIXED**: Exit loop after death
          if(it.type==='goal'){ nextLevel(); return; } // **FIXED**: Exit loop after level win
        }
      } 
    }

    // **IMPROVED**: Logic to handle moving platforms
    if(!player.onGround) player.standingOn = null; // Not on ground anymore
    if(player.onGround && player.standingOn && player.standingOn.type === 'moving'){
      const platform = player.standingOn;
      const dx_plat = platform.x - platform._prevX;
      const dy_plat = platform.y - platform._prevY;
      player.x += dx_plat;
      player.y += dy_plat;
    }
  }

  // time tracking for moving platforms
  let lastMs = performance.now();
  function update(){
    const now = performance.now(); const dt = now - lastMs; lastMs = now;
    const accel = 1.0; 
    const scale = dt/16; // Use this scale for frame-rate-independent movement

    if(keys['arrowleft']||keys['a']) player.vx -= accel;
    if(keys['arrowright']||keys['d']) player.vx += accel;

    // **IMPROVED**: Jumping is now frame-rate independent
    if((keys['arrowup']||keys['w']||keys[' ']) && player.onGround){ 
      player.vy = -16 * (dt/16); // **FIXED**: Apply jump force scaled by time
      player.onGround=false; 
      player.standingOn = null; // **IMPROVED**: Stop standing on platform when jumping
    }
    if(keys['z']) applyShrink(true); else if(keys['x']) applyShrink(false);

    // moving platforms update - DO THIS BEFORE PLAYER MOVEMENT
    updateMovingPlatforms(levels[currentLevel], dt);

    // physics
    player.vy += gravity * scale;
    // **IMPROVED**: Apply stronger friction only on the ground for better air control
    if(player.onGround) player.vx *= friction;
    else player.vx *= airDrag;

    player.x += player.vx * scale;
    player.y += player.vy * scale;

    // bounds
    if(player.x - player.r < 0){ player.x = player.r; player.vx=0; }
    if(player.x + player.r > W){ player.x = W - player.r; player.vx=0; }
    if(player.y - player.r < 0){ player.y = player.r; player.vy = 0; }
    if(player.y - player.r > H+220){ dieAndRespawn(); }

    resolveCollisions(dt); // **FIXED**: call with dt
  }
// ... (Draw and loop functions remain the same) ...
